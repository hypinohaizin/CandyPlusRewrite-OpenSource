package me.hypinohaizin.candyplusrewrite.module.exploit;

import me.hypinohaizin.candyplusrewrite.utils.InventoryUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import me.hypinohaizin.candyplusrewrite.event.events.world.BlockEvent;
import me.hypinohaizin.candyplusrewrite.event.events.network.PacketEvent;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.init.Items;
import net.minecraft.util.EnumHand;
import me.hypinohaizin.candyplusrewrite.CandyPlusRewrite;
import me.hypinohaizin.candyplusrewrite.utils.RenderUtil3D;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.EnumFacing;
import me.hypinohaizin.candyplusrewrite.utils.Timer;
import java.awt.Color;
import me.hypinohaizin.candyplusrewrite.setting.Setting;
import me.hypinohaizin.candyplusrewrite.module.Module;

public class InstantMine extends Module {
    public Setting<Boolean> autoBreak;
    public Setting<Integer> delay;
    public Setting<Boolean> picOnly;
    public Setting<Color> color;
    public Setting<Boolean> outline;
    public Setting<Float> width;
    public Setting<Boolean> silentSwitch;
    private static boolean packetCancel;
    private static Timer breaktimer;
    private static Timer timer;
    private static EnumFacing direction;
    public static BlockPos FourZeroFourBlock;
    private static BlockPos lastBlock;

    private int previousSlot = -1;

    public InstantMine() {
        super("InstantMine", Categories.EXPLOIT, false, false);
        autoBreak = register(new Setting<>("AutoBreak", true));
        delay = register(new Setting<>("Delay", 20, 500, 0));
        picOnly = register(new Setting<>("Only Pickaxe", true));
        color = register(new Setting<>("Color", new Color(0, 0, 230, 90)));
        outline = register(new Setting<>("Outline", false));
        width = register(new Setting<>("Width", 2.0f, 5.0f, 0.2f, v -> outline.getValue()));
        silentSwitch = register(new Setting<>("SilentSwitch", true));
    }

    @Override
    public void onRender3D() {
        if (InstantMine.FourZeroFourBlock != null) {
            RenderUtil3D.drawBox(InstantMine.FourZeroFourBlock, 1.0, color.getValue(), 63);
            if (outline.getValue()) {
                RenderUtil3D.drawBoundingBox(InstantMine.FourZeroFourBlock, 1.0, width.getValue(), color.getValue());
            }
        }
    }

    @Override
    public void onUpdate() {
        if (!CandyPlusRewrite.m_module.getModuleWithClass(SilentPickel.class).isEnable) {
            update();
        }
    }

    public void update() {
        if (nullCheck()) return;
        if (InstantMine.FourZeroFourBlock != null && autoBreak.getValue() && InstantMine.breaktimer.passedMs(delay.getValue())) {
            if (picOnly.getValue()) {
                if (mc.player.inventory.getCurrentItem().getItem() != Items.DIAMOND_PICKAXE) return;
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, InstantMine.FourZeroFourBlock, InstantMine.direction));
            } else {
                int bestPickSlot = getFastestPickaxeSlot();
                if (bestPickSlot != -1) {
                    previousSlot = mc.player.inventory.currentItem;
                    if (silentSwitch.getValue()) {
                        mc.player.connection.sendPacket(new net.minecraft.network.play.client.CPacketHeldItemChange(bestPickSlot));
                    } else {
                        InventoryUtil.switchToHotbarSlot(bestPickSlot, true);
                    }
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, InstantMine.FourZeroFourBlock, InstantMine.direction));
                    if (silentSwitch.getValue() && previousSlot != -1) {
                        mc.player.connection.sendPacket(new net.minecraft.network.play.client.CPacketHeldItemChange(previousSlot));
                    } else {
                        InventoryUtil.switchToHotbarSlot(previousSlot, true);
                    }
                } else {
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, InstantMine.FourZeroFourBlock, InstantMine.direction));
                }
            }
            InstantMine.breaktimer.reset();
        }
    }

    private int getFastestPickaxeSlot() {
        int bestSlot = -1;
        float bestSpeed = 0.0f;
        for (int i = 0; i < 9; i++) {
            ItemStack stack = mc.player.inventory.getStackInSlot(i);
            if (stack.getItem() == Items.DIAMOND_PICKAXE) {
                float speed = stack.getDestroySpeed(mc.world.getBlockState(FourZeroFourBlock));
                if (speed > bestSpeed) {
                    bestSpeed = speed;
                    bestSlot = i;
                }
            }
        }
        return bestSlot;
    }

    @Override
    public void onPacketSend(final PacketEvent.Send event) {
        if (nullCheck()) return;
        final Packet<?> packet = event.getPacket();
        if (packet instanceof CPacketPlayerDigging && ((CPacketPlayerDigging) packet).getAction() == CPacketPlayerDigging.Action.START_DESTROY_BLOCK && InstantMine.packetCancel) {
            event.cancel();
        }
    }

    @SubscribeEvent
    public void OnDamageBlock(final BlockEvent event) {
        if (nullCheck()) return;
        if (!isEnable) return;
        startBreak(event.pos, event.facing);
        event.cancel();
    }

    public static void startBreak(final BlockPos pos, final EnumFacing facing) {
        if (!canBreak(pos)) {
            resetMining();
            return;
        }
        if (lastBlock == null || !pos.equals(lastBlock)) {
            resetMining();
            packetCancel = false;
            mc.player.swingArm(EnumHand.MAIN_HAND);
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
        }
        packetCancel = true;
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, facing));
        FourZeroFourBlock = pos;
        lastBlock = pos;
        direction = facing;
    }

    private static boolean canBreak(final BlockPos pos) {
        final IBlockState blockState = InstantMine.mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, InstantMine.mc.world, pos) != -1.0f;
    }

    public static void cancelMining() {
        if (FourZeroFourBlock != null && direction != null) {
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, FourZeroFourBlock, direction));
            resetMining();
        }
    }

    public static void resetMining() {
        FourZeroFourBlock = null;
        lastBlock = null;
        direction = null;
        packetCancel = false;
    }

    static {
        InstantMine.packetCancel = false;
        InstantMine.breaktimer = new Timer();
        InstantMine.timer = new Timer();
    }
}
