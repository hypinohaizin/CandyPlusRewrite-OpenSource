package me.hypinohaizin.candyplusrewrite.module.exploit;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.EnumFacing;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.init.Blocks;
import me.hypinohaizin.candyplusrewrite.utils.BlockUtil;
import net.minecraft.util.math.BlockPos;
import me.hypinohaizin.candyplusrewrite.utils.PlayerUtil;
import me.hypinohaizin.candyplusrewrite.utils.InventoryUtil;
import net.minecraft.block.BlockTrapDoor;
import net.minecraft.util.EnumHand;
import me.hypinohaizin.candyplusrewrite.setting.Setting;
import me.hypinohaizin.candyplusrewrite.module.Module;

public class TrapPhase extends Module
{
    public Setting<Float> offset;
    public Setting<Boolean> silentSwitch;
    public Setting<Boolean> packetPlace;
    private EnumHand oldhand;
    private int oldslot;
    
    public TrapPhase() {
        super("TrapPhase", Categories.EXPLOIT, false, false);
        offset = register(new Setting<>("Offset", 0.6f, 1.0f, 0.0f));
        silentSwitch = register(new Setting<>("SilentSwitch", true));
        packetPlace = register(new Setting<>("PacketPlace", true));
        oldhand = null;
        oldslot = -1;
    }
    
    @Override
    public void onTick() {
        if (nullCheck()) {
            return;
        }
        final int slot = InventoryUtil.findHotbarBlockWithClass(BlockTrapDoor.class);
        if (slot == -1) {
            sendMessage("Cannot find TrapDoor! disabling");
            disable();
            return;
        }
        final BlockPos playerPos = PlayerUtil.getPlayerPos();
        BlockPos trappos = null;
        final BlockPos[] array;
        final BlockPos[] offsets = array = new BlockPos[] { new BlockPos(1, 0, 0), new BlockPos(-1, 0, 0), new BlockPos(0, 0, 1), new BlockPos(0, 0, -1) };
        for (final BlockPos offset : array) {
            final BlockPos pos = playerPos.add(offset);
            if (entityCheck(pos)) {
                if (!BlockUtil.getBlock(pos).equals(Blocks.AIR) || !BlockUtil.canRightClickForPlace(pos)) {
                    trappos = pos;
                }
            }
        }
        if (trappos == null) {
            sendMessage("Cannot find space! disabling");
            disable();
            return;
        }
        setItem(slot);
        final double x = TrapPhase.mc.player.posX;
        final double y = TrapPhase.mc.player.posY;
        final double z = TrapPhase.mc.player.posZ;
        TrapPhase.mc.player.connection.sendPacket(new CPacketPlayer.Position(x, y + offset.getValue(), z, TrapPhase.mc.player.onGround));
        EnumFacing facing = null;
        for (final EnumFacing f : EnumFacing.values()) {
            if (trappos.add(f.getDirectionVec()).equals(playerPos)) {
                facing = f;
            }
        }
        BlockUtil.rightClickBlock(trappos, facing, new Vec3d(0.5, 0.8, 0.5), packetPlace.getValue());
        TrapPhase.mc.player.connection.sendPacket(new CPacketPlayer.Position(x, y, z, TrapPhase.mc.player.onGround));
        restoreItem();
        disable();
    }
    
    public boolean entityCheck(final BlockPos pos) {
        return TrapPhase.mc.world.getEntitiesWithinAABB(Entity.class, new AxisAlignedBB(pos), e -> e instanceof EntityEnderCrystal || e instanceof EntityPlayer).isEmpty();
    }
    
    public void setItem(final int slot) {
        if (silentSwitch.getValue()) {
            oldhand = null;
            if (TrapPhase.mc.player.isHandActive()) {
                oldhand = TrapPhase.mc.player.getActiveHand();
            }
            oldslot = TrapPhase.mc.player.inventory.currentItem;
            TrapPhase.mc.player.connection.sendPacket(new CPacketHeldItemChange(slot));
        }
        else {
            TrapPhase.mc.player.inventory.currentItem = slot;
            TrapPhase.mc.playerController.updateController();
        }
    }
    
    public void restoreItem() {
        if (oldslot != -1 && silentSwitch.getValue()) {
            if (oldhand != null) {
                TrapPhase.mc.player.setActiveHand(oldhand);
            }
            TrapPhase.mc.player.connection.sendPacket(new CPacketHeldItemChange(oldslot));
            oldslot = -1;
            oldhand = null;
        }
    }
}
